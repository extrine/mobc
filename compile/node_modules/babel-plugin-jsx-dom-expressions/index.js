'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var SyntaxJSX = _interopDefault(require('@babel/plugin-syntax-jsx'));
var t = require('@babel/types');
var helperModuleImports = require('@babel/helper-module-imports');

var config = {
  moduleName: "dom",
  generate: "dom",
  hydratable: false,
  delegateEvents: true,
  nonDelegateEvents: [],
  builtIns: [],
  wrapConditionals: true,
  contextToCustomElements: false,
  hydratableEvents: null,
  staticMarker: "@once"
};

const Types = {
    ATTRIBUTE: "attribute",
    PROPERTY: "property"
  },
  Attributes = {
    href: {
      type: Types.ATTRIBUTE
    },
    style: {
      type: Types.PROPERTY,
      alias: "style.cssText"
    },
    for: {
      type: Types.PROPERTY,
      alias: "htmlFor"
    },
    class: {
      type: Types.PROPERTY,
      alias: "className"
    },
    // React compat
    spellCheck: {
      type: Types.PROPERTY,
      alias: "spellcheck"
    },
    allowFullScreen: {
      type: Types.PROPERTY,
      alias: "allowFullscreen"
    },
    autoCapitalize: {
      type: Types.PROPERTY,
      alias: "autocapitalize"
    },
    autoFocus: {
      type: Types.PROPERTY,
      alias: "autofocus"
    },
    autoPlay: {
      type: Types.PROPERTY,
      alias: "autoplay"
    }
  },
  SVGAttributes = {
    className: {
      type: Types.ATTRIBUTE,
      alias: "class"
    },
    htmlFor: {
      type: Types.ATTRIBUTE,
      alias: "for"
    },
    tabIndex: {
      type: Types.ATTRIBUTE,
      alias: "tabindex"
    },
    allowReorder: {
      type: Types.ATTRIBUTE
    },
    attributeName: {
      type: Types.ATTRIBUTE
    },
    attributeType: {
      type: Types.ATTRIBUTE
    },
    autoReverse: {
      type: Types.ATTRIBUTE
    },
    baseFrequency: {
      type: Types.ATTRIBUTE
    },
    calcMode: {
      type: Types.ATTRIBUTE
    },
    clipPathUnits: {
      type: Types.ATTRIBUTE
    },
    contentScriptType: {
      type: Types.ATTRIBUTE
    },
    contentStyleType: {
      type: Types.ATTRIBUTE
    },
    diffuseConstant: {
      type: Types.ATTRIBUTE
    },
    edgeMode: {
      type: Types.ATTRIBUTE
    },
    externalResourcesRequired: {
      type: Types.ATTRIBUTE
    },
    filterRes: {
      type: Types.ATTRIBUTE
    },
    filterUnits: {
      type: Types.ATTRIBUTE
    },
    gradientTransform: {
      type: Types.ATTRIBUTE
    },
    gradientUnits: {
      type: Types.ATTRIBUTE
    },
    kernelMatrix: {
      type: Types.ATTRIBUTE
    },
    kernelUnitLength: {
      type: Types.ATTRIBUTE
    },
    keyPoints: {
      type: Types.ATTRIBUTE
    },
    keySplines: {
      type: Types.ATTRIBUTE
    },
    keyTimes: {
      type: Types.ATTRIBUTE
    },
    lengthAdjust: {
      type: Types.ATTRIBUTE
    },
    limitingConeAngle: {
      type: Types.ATTRIBUTE
    },
    markerHeight: {
      type: Types.ATTRIBUTE
    },
    markerUnits: {
      type: Types.ATTRIBUTE
    },
    maskContentUnits: {
      type: Types.ATTRIBUTE
    },
    maskUnits: {
      type: Types.ATTRIBUTE
    },
    numOctaves: {
      type: Types.ATTRIBUTE
    },
    pathLength: {
      type: Types.ATTRIBUTE
    },
    patternContentUnits: {
      type: Types.ATTRIBUTE
    },
    patternTransform: {
      type: Types.ATTRIBUTE
    },
    patternUnits: {
      type: Types.ATTRIBUTE
    },
    pointsAtX: {
      type: Types.ATTRIBUTE
    },
    pointsAtY: {
      type: Types.ATTRIBUTE
    },
    pointsAtZ: {
      type: Types.ATTRIBUTE
    },
    preserveAlpha: {
      type: Types.ATTRIBUTE
    },
    preserveAspectRatio: {
      type: Types.ATTRIBUTE
    },
    primitiveUnits: {
      type: Types.ATTRIBUTE
    },
    refX: {
      type: Types.ATTRIBUTE
    },
    refY: {
      type: Types.ATTRIBUTE
    },
    repeatCount: {
      type: Types.ATTRIBUTE
    },
    repeatDur: {
      type: Types.ATTRIBUTE
    },
    requiredExtensions: {
      type: Types.ATTRIBUTE
    },
    requiredFeatures: {
      type: Types.ATTRIBUTE
    },
    specularConstant: {
      type: Types.ATTRIBUTE
    },
    specularExponent: {
      type: Types.ATTRIBUTE
    },
    spreadMethod: {
      type: Types.ATTRIBUTE
    },
    startOffset: {
      type: Types.ATTRIBUTE
    },
    stdDeviation: {
      type: Types.ATTRIBUTE
    },
    stitchTiles: {
      type: Types.ATTRIBUTE
    },
    surfaceScale: {
      type: Types.ATTRIBUTE
    },
    systemLanguage: {
      type: Types.ATTRIBUTE
    },
    tableValues: {
      type: Types.ATTRIBUTE
    },
    targetX: {
      type: Types.ATTRIBUTE
    },
    targetY: {
      type: Types.ATTRIBUTE
    },
    textLength: {
      type: Types.ATTRIBUTE
    },
    viewBox: {
      type: Types.ATTRIBUTE
    },
    viewTarget: {
      type: Types.ATTRIBUTE
    },
    xChannelSelector: {
      type: Types.ATTRIBUTE
    },
    yChannelSelector: {
      type: Types.ATTRIBUTE
    },
    zoomAndPan: {
      type: Types.ATTRIBUTE
    }
  };

// list of Element events that will not be delegated even if camelCased
const NonComposedEvents = new Set([
  "abort",
  "animationstart",
  "animationend",
  "animationiteration",
  "blur",
  "change",
  "copy",
  "cut",
  "error",
  "focus",
  "gotpointercapture",
  "load",
  "loadend",
  "loadstart",
  "lostpointercapture",
  "mouseenter",
  "mouseleave",
  "paste",
  "progress",
  "reset",
  "scroll",
  "select",
  "submit",
  "transitionstart",
  "transitioncancel",
  "transitionend",
  "transitionrun"
]);

const SVGElements = new Set([
  // "a",
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  // "script",
  "set",
  "stop",
  // "style",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  // "title",
  "tref",
  "tspan",
  "use",
  "view",
  "vkern"
]);

const SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};

var VoidElements = [
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'command',
  'embed',
  'frame',
  'hr',
  'image',
  'img',
  'input',
  'isindex',
  'keygen',
  'link',
  'menuitem',
  'meta',
  'nextid',
  'param',
  'source',
  'track',
  'wbr'
];

const reservedNameSpaces = {
  style: true
};

function registerImportMethod(path, name) {
  const imports =
    path.scope.getProgramParent().data.imports ||
    (path.scope.getProgramParent().data.imports = new Set());
  if (!imports.has(name)) {
    helperModuleImports.addNamed(path, name, config.moduleName, { nameHint: `_$${name}` });
    imports.add(name);
  }
}

function jsxElementNameToString(node) {
  if (t.isJSXMemberExpression(node)) {
    return `${jsxElementNameToString(node.object)}.${node.property.name}`;
  }
  if (t.isJSXIdentifier(node)) {
    return node.name;
  }
  return `${node.namespace.name}:${node.name.name}`;
}

function tagNameToIdentifier(name) {
  const parts = name.split(".");
  if (parts.length === 1) return t.identifier(name);
  let part;
  let base = t.identifier(parts.shift());
  while ((part = parts.shift())) {
    base = t.memberExpression(base, t.identifier(part));
  }
  return base;
}

function getTagName(tag) {
  const jsxName = tag.openingElement.name;
  return jsxElementNameToString(jsxName);
}

function isComponent(tagName) {
  return (
    (tagName[0] && tagName[0].toLowerCase() !== tagName[0]) ||
    tagName.includes(".") ||
    /[^a-zA-Z]/.test(tagName[0])
  );
}

function isDynamic(path, { checkMember, checkTags }) {
  const expr = path.node;
  if (t.isFunction(expr)) return false;
  if (expr.leadingComments && expr.leadingComments[0].value.trim() === config.staticMarker) {
    expr.leadingComments.shift();
    return false;
  }
  if (
    t.isCallExpression(expr) ||
    (checkMember && t.isMemberExpression(expr)) ||
    (checkTags && (t.isJSXElement(expr) || t.isJSXFragment(expr)))
  )
    return true;

  let dynamic;
  path.traverse({
    Function(p) {
      p.skip();
    },
    CallExpression(p) {
      dynamic = true;
      p.stop();
    },
    MemberExpression(p) {
      checkMember && (dynamic = true) && p.stop();
    },
    JSXElement(p) {
      checkTags ? (dynamic = true) && p.stop() : p.skip();
    },
    JSXFragment(p) {
      checkTags ? (dynamic = true) && p.stop() : p.skip();
    }
  });
  return dynamic;
}

function isStaticExpressionContainer(path) {
  const node = path.node;
  return (
    t.isJSXExpressionContainer(node) &&
    t.isJSXElement(path.parent) &&
    !isComponent(getTagName(path.parent)) &&
    (t.isStringLiteral(node.expression) ||
      t.isNumericLiteral(node.expression) ||
      (t.isTemplateLiteral(node.expression) && node.expression.expressions.length === 0))
  );
}

// remove unnecessary JSX Text nodes
function filterChildren(children, loose) {
  return children.filter(
    ({ node: child }) =>
      !(t.isJSXExpressionContainer(child) && t.isJSXEmptyExpression(child.expression)) &&
      (!t.isJSXText(child) ||
        (loose ? !/^[\r\n]\s*$/.test(child.extra.raw) : !/^\s*$/.test(child.extra.raw)))
  );
}

function checkLength(children) {
  let i = 0;
  children.forEach(path => {
    const child = path.node;
    !(t.isJSXExpressionContainer(child) && t.isJSXEmptyExpression(child.expression)) &&
      (!t.isJSXText(child) || !/^\s*$/.test(child.extra.raw)) &&
      i++;
  });
  return i > 1;
}

function trimWhitespace(text) {
  text = text.replace(/\r/g, "");
  if (/\n/g.test(text)) {
    text = text
      .split("\n")
      .map((t, i) => (i ? t.replace(/^\s*/g, "") : t))
      .filter(s => !/^\s*$/.test(s))
      .join(" ");
  }
  return text.replace(/\s+/g, " ");
}

function toEventName(name) {
  return name.slice(2).toLowerCase();
}

function transformCondition(path, deep) {
  const expr = path.node;
  registerImportMethod(path, "memo");
  let dTest, cond;
  if (
    t.isConditionalExpression(expr) &&
    (isDynamic(path.get("consequent"), {
      checkTags: true
    }) ||
      isDynamic(path.get("alternate"), { checkTags: true }))
  ) {
    dTest = isDynamic(path.get("test"), { checkMember: true });
    if (dTest) {
      cond = expr.test;
      if (!t.isBinaryExpression(cond))
        cond = t.unaryExpression("!", t.unaryExpression("!", cond, true), true);
      expr.test = t.callExpression(t.identifier("_c$"), []);
      if (t.isConditionalExpression(expr.consequent) || t.isLogicalExpression(expr.consequent)) {
        expr.consequent = transformCondition(path.get("consequent"), true);
      }
      if (t.isConditionalExpression(expr.alternate) || t.isLogicalExpression(expr.alternate)) {
        expr.alternate = transformCondition(path.get("alternate"), true);
      }
    }
  } else if (t.isLogicalExpression(expr)) {
    let nextPath = path;
    // handle top-level or, ie cond && <A/> || <B/>
    if (expr.operator === "||" && t.isLogicalExpression(expr.left)) {
      nextPath = nextPath.get("left");
    }
    isDynamic(nextPath.get("right"), { checkTags: true }) &&
      (dTest = isDynamic(nextPath.get("left"), {
        checkMember: true
      }));
    if (dTest) {
      cond = nextPath.node.left;
      if (expr.operator !== "||" && !t.isBinaryExpression(cond))
        cond = t.unaryExpression("!", t.unaryExpression("!", cond, true), true);
      nextPath.node.left = t.callExpression(t.identifier("_c$"), []);
    }
  }
  if (dTest) {
    return t.callExpression(
      t.arrowFunctionExpression(
        [],
        t.blockStatement([
          t.variableDeclaration("const", [
            t.variableDeclarator(
              t.identifier("_c$"),
              t.callExpression(t.identifier("_$memo"), [
                t.arrowFunctionExpression([], cond),
                t.booleanLiteral(true)
              ])
            )
          ]),
          t.returnStatement(t.arrowFunctionExpression([], expr))
        ])
      ),
      []
    );
  }
  return deep ? expr : t.arrowFunctionExpression([], expr);
}

const ATTR_REGEX = /[&<"]/g,
  CONTENT_REGEX = /[&<]/g;

function escapeHTML(html, attr) {
  if (typeof html !== "string") return html;
  return html.replace(attr ? ATTR_REGEX : CONTENT_REGEX, m => {
    switch (m) {
      case "&":
        return "&amp;";
      case "<":
        return "&lt;";
      case '"':
        return "&quot;";
    }
  });
}

function transformElement(path, info) {
  let tagName = getTagName(path.node),
    wrapSVG = info.topLevel && tagName != "svg" && SVGElements.has(tagName),
    voidTag = VoidElements.indexOf(tagName) > -1,
    results = {
      template: `<${tagName}`,
      decl: [],
      exprs: [],
      dynamics: [],
      postExprs: [],
      isSVG: wrapSVG
    };
  if (wrapSVG) results.template = "<svg>" + results.template;
  if (!info.skipId) results.id = path.scope.generateUidIdentifier("el$");
  transformAttributes(path, results);
  if (config.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1)) {
    contextToCustomElement(path, results);
  }
  results.template += ">";
  if (!voidTag) {
    transformChildren(path, results);
    results.template += `</${tagName}>`;
  }
  if (info.topLevel && config.hydratable && results.hasHydratableEvent) {
    registerImportMethod(path, "runHydrationEvents");
    results.postExprs.push(
      t.expressionStatement(t.callExpression(t.identifier("_$runHydrationEvents"), [results.id]))
    );
  }
  if (wrapSVG) results.template += "</svg>";
  return results;
}

function setAttr(path, elem, name, value, isSVG, dynamic, prevId) {
  if (name.startsWith("style:")) {
    const key = name.slice(6);
    return t.callExpression(
      t.memberExpression(
        t.memberExpression(elem, t.identifier("style")),
        t.identifier("setProperty")
      ),
      [t.stringLiteral(key), value]
    );
  }

  if (name === "style") {
    registerImportMethod(path, "style");
    return t.callExpression(
      t.identifier("_$style"),
      prevId ? [elem, value, prevId] : [elem, value]
    );
  }

  if (name === "classList") {
    registerImportMethod(path, "classList");
    return t.callExpression(
      t.identifier("_$classList"),
      prevId ? [elem, value, prevId] : [elem, value]
    );
  }

  if (dynamic && name === "textContent") {
    return t.assignmentExpression("=", t.memberExpression(elem, t.identifier("data")), value);
  }

  let isNameSpaced = name.indexOf(":") > -1,
    isAttribute = isSVG || name.indexOf("-") > -1 || isNameSpaced,
    attribute = isSVG ? SVGAttributes[name] : Attributes[name];

  if (attribute) {
    if (attribute.type === "attribute") isAttribute = true;
    if (attribute.alias) name = attribute.alias;
  } else if (isSVG) name = name.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);

  if (isAttribute) {
    const ns = isNameSpaced && SVGNamespace[name.split(":")[0]];
    if (ns) {
      registerImportMethod(path, "setAttributeNS");
      return t.callExpression(t.identifier("_$setAttributeNS"), [
        elem,
        t.stringLiteral(ns),
        t.stringLiteral(name),
        value
      ]);
    } else {
      registerImportMethod(path, "setAttribute");
      return t.callExpression(t.identifier("_$setAttribute"), [elem, t.stringLiteral(name), value]);
    }
  }
  return t.assignmentExpression("=", t.memberExpression(elem, t.identifier(name)), value);
}

function transformAttributes(path, results) {
  let elem = results.id,
    hasHydratableEvent = false,
    children;
  const spread = t.identifier("_$spread"),
    tagName = getTagName(path.node),
    isSVG = SVGElements.has(tagName),
    hasChildren = path.node.children.length > 0,
    attributes = path.get("openingElement").get("attributes"),
    classAttributes = attributes.filter(
      a => a.node.name && (a.node.name.name === "class" || a.node.name.name === "className")
    );
  // combine class propertoes
  if (classAttributes.length > 1) {
    const first = classAttributes[0].node,
      values = [],
      quasis = [t.TemplateElement({ raw: "" })];
    for (let i = 0; i < classAttributes.length; i++) {
      const attr = classAttributes[i].node,
        isLast = i === classAttributes.length - 1;
      if (!t.isJSXExpressionContainer(attr.value)) {
        quasis.pop();
        quasis.push(
          t.TemplateElement({ raw: (i ? " " : "") + `${attr.value.value}` + (isLast ? "" : " ") })
        );
      } else {
        values.push(attr.value.expression);
        quasis.push(t.TemplateElement({ raw: isLast ? "" : " " }));
      }
      i && attributes.splice(classAttributes[i].key);
    }
    first.value = t.JSXExpressionContainer(t.TemplateLiteral(quasis, values));
  }
  path.get("openingElement").set(
    "attributes",
    attributes.map(a => a.node)
  );

  // preprocess styles
  const styleAttribute = attributes.find(
    a =>
      a.node.name &&
      a.node.name.name === "style" &&
      t.isJSXExpressionContainer(a.node.value) &&
      t.isObjectExpression(a.node.value.expression) &&
      !a.node.value.expression.properties.some(p => t.isSpreadElement(p))
  );
  if (styleAttribute) {
    let i = 0,
      leading = styleAttribute.node.value.expression.leadingComments;
    styleAttribute.node.value.expression.properties.slice().forEach((p, index) => {
      if (!p.computed) {
        if (leading) p.value.leadingComments = leading;
        path
          .get("openingElement")
          .node.attributes.splice(
            styleAttribute.key + ++i,
            0,
            t.JSXAttribute(
              t.JSXNamespacedName(
                t.JSXIdentifier("style"),
                t.JSXIdentifier(t.isIdentifier(p.key) ? p.key.name : p.key.value)
              ),
              t.JSXExpressionContainer(p.value)
            )
          );
        styleAttribute.node.value.expression.properties.splice(index - i - 1, 1);
      }
    });
    if (!styleAttribute.node.value.expression.properties.length)
      path.get("openingElement").node.attributes.splice(styleAttribute.key, 1);
  }

  path
    .get("openingElement")
    .get("attributes")
    .forEach(attribute => {
      const node = attribute.node;
      if (t.isJSXSpreadAttribute(node)) {
        registerImportMethod(attribute, "spread");
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(spread, [
              elem,
              isDynamic(attribute.get("argument"), {
                checkMember: true
              })
                ? t.arrowFunctionExpression([], node.argument)
                : node.argument,
              t.booleanLiteral(isSVG),
              t.booleanLiteral(hasChildren)
            ])
          )
        );
        //NOTE: can't be checked at compile time so add to compiled output
        hasHydratableEvent = true;
        return;
      }

      let value = node.value,
        key = t.isJSXNamespacedName(node.name)
          ? `${node.name.namespace.name}:${node.name.name.name}`
          : node.name.name,
        reservedNameSpace =
          t.isJSXNamespacedName(node.name) && reservedNameSpaces[node.name.namespace.name];
      if (
        t.isJSXNamespacedName(node.name) &&
        reservedNameSpace &&
        !t.isJSXExpressionContainer(value)
      ) {
        node.value = value = t.JSXExpressionContainer(value);
      }
      if (
        t.isJSXExpressionContainer(value) &&
        (reservedNameSpace ||
          !(t.isStringLiteral(value.expression) || t.isNumericLiteral(value.expression)))
      ) {
        if (key === "ref") {
          if (t.isLVal(value.expression)) {
            results.exprs.unshift(
              t.expressionStatement(
                t.conditionalExpression(
                  t.binaryExpression(
                    "===",
                    t.unaryExpression("typeof", value.expression),
                    t.stringLiteral("function")
                  ),
                  t.callExpression(value.expression, [elem]),
                  t.assignmentExpression("=", value.expression, elem)
                )
              )
            );
          } else if (t.isFunction(value.expression)) {
            results.exprs.unshift(
              t.expressionStatement(t.callExpression(value.expression, [elem]))
            );
          }
        } else if (key === "children") {
          children = value;
        } else if (key.startsWith("on")) {
          if (config.generate === "dom-ssr") return;
          const ev = toEventName(key);
          if (!ev || ev === "capture") {
            value.expression.properties.forEach(prop => {
              const listenerOptions = [
                t.stringLiteral(prop.key.name || prop.key.value),
                prop.value
              ];
              results.exprs.push(
                t.expressionStatement(
                  t.callExpression(
                    t.memberExpression(elem, t.identifier("addEventListener")),
                    ev ? listenerOptions.concat(t.booleanLiteral(true)) : listenerOptions
                  )
                )
              );
            });
          } else if (
            config.delegateEvents &&
            !NonComposedEvents.has(ev) &&
            config.nonDelegateEvents.indexOf(ev) === -1
          ) {
            // can only hydrate delegated events
            hasHydratableEvent = config.hydratableEvents
              ? config.hydratableEvents.includes(ev)
              : true;
            const events =
              attribute.scope.getProgramParent().data.events ||
              (attribute.scope.getProgramParent().data.events = new Set());
            events.add(ev);
            let handler = value.expression;
            if (t.isArrayExpression(value.expression)) {
              handler = value.expression.elements[0];
              results.exprs.unshift(
                t.expressionStatement(
                  t.assignmentExpression(
                    "=",
                    t.memberExpression(t.identifier(elem.name), t.identifier(`__${ev}Data`)),
                    value.expression.elements[1]
                  )
                )
              );
            }
            results.exprs.unshift(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(t.identifier(elem.name), t.identifier(`__${ev}`)),
                  handler
                )
              )
            );
          } else {
            let handler = value.expression;
            if (t.isArrayExpression(value.expression)) {
              handler = t.arrowFunctionExpression(
                [t.identifier("e")],
                t.callExpression(value.expression.elements[0], [
                  value.expression.elements[1],
                  t.identifier("e")
                ])
              );
            }
            results.exprs.unshift(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(t.identifier(elem.name), t.identifier(`on${ev}`)),
                  handler
                )
              )
            );
          }
        } else if (
          isDynamic(attribute.get("value").get("expression"), {
            checkMember: true
          })
        ) {
          let nextElem = elem;
          if (key === "textContent") {
            const textId = attribute.scope.generateUidIdentifier("el$");
            results.exprs.push(
              t.expressionStatement(
                t.assignmentExpression(
                  "=",
                  t.memberExpression(elem, t.identifier("textContent")),
                  value.expression
                )
              ),
              t.variableDeclaration("const", [
                t.variableDeclarator(textId, t.memberExpression(elem, t.identifier("firstChild")))
              ])
            );
            nextElem = textId;
          }
          results.dynamics.push({ elem: nextElem, key, value: value.expression, isSVG });
        } else {
          results.exprs.push(
            t.expressionStatement(setAttr(attribute, elem, key, value.expression, isSVG))
          );
        }
      } else {
        if (t.isJSXExpressionContainer(value)) value = value.expression;
        if (isSVG) {
          const attr = SVGAttributes[key];

          if (attr) {
            if (attr.alias) key = attr.alias;
          } else key = key.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);
        } else {
          const attr = SVGAttributes[key];
          if (attr && attr.alias) key = attr.alias;
          key = key.toLowerCase();
        }
        results.template += ` ${key}`;
        results.template += value ? `="${value.value}"` : `=""`;
      }
    });
  if (!hasChildren && children) {
    path.node.children.push(children);
  }

  results.hasHydratableEvent = results.hasHydratableEvent || hasHydratableEvent;
}

function wrappedByText(list, startIndex) {
  let index = startIndex,
    wrapped;
  while (--index >= 0) {
    const node = list[index];
    if (!node) continue;
    if (node.text) {
      wrapped = true;
      break;
    }
    if (node.id) return false;
  }
  if (!wrapped) return false;
  index = startIndex;
  while (++index < list.length) {
    const node = list[index];
    if (!node) continue;
    if (node.text) return true;
    if (node.id) return false;
  }
  return false;
}

function transformChildren(path, results) {
  const { generate, hydratable } = config;
  let tempPath = results.id && results.id.name,
    nextPlaceholder,
    i = 0;
  const filteredChildren = filterChildren(path.get("children"), true),
    childNodes = filteredChildren
      .map(
        (child, index) =>
          transformNode(child, {
            skipId: !results.id || !detectExpressions(filteredChildren, index)
          })
        // combine adjacent textNodes
      )
      .reduce((memo, child) => {
        if (!child) return memo;
        const i = memo.length;
        if (child.text && i && memo[i - 1].text) {
          memo[i - 1].template += child.template;
        } else memo.push(child);
        return memo;
      }, []);

  childNodes.forEach((child, index) => {
    if (!child) return;
    results.template += child.template;
    if (child.id) {
      results.decl.push(
        t.variableDeclarator(
          child.id,
          t.memberExpression(
            t.identifier(tempPath),
            t.identifier(i === 0 ? "firstChild" : "nextSibling")
          )
        )
      );
      results.decl.push(...child.decl);
      results.exprs.push(...child.exprs);
      results.dynamics.push(...child.dynamics);
      results.hasHydratableEvent = results.hasHydratableEvent || child.hasHydratableEvent;
      tempPath = child.id.name;
      nextPlaceholder = null;
      i++;
    } else if (child.exprs.length) {
      registerImportMethod(path, "insert");
      const multi = checkLength(filteredChildren),
        markers = (generate === "dom-ssr" || hydratable) && multi;
      // boxed by textNodes
      if (markers || wrappedByText(childNodes, index)) {
        let exprId, contentId;
        if (markers) tempPath = createPlaceholder(path, results, tempPath, i++, "#")[0].name;
        if (nextPlaceholder) {
          exprId = nextPlaceholder;
        } else {
          [exprId, contentId] = createPlaceholder(path, results, tempPath, i++, markers ? "/" : "");
        }
        if (!markers) nextPlaceholder = exprId;
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(
              t.identifier("_$insert"),
              contentId
                ? [results.id, child.exprs[0], exprId, contentId]
                : [results.id, child.exprs[0], exprId]
            )
          )
        );
        tempPath = exprId.name;
      } else if (multi) {
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(t.identifier("_$insert"), [
              results.id,
              child.exprs[0],
              nextChild(childNodes, index) || t.nullLiteral()
            ])
          )
        );
      } else {
        results.exprs.push(
          t.expressionStatement(
            t.callExpression(
              t.identifier("_$insert"),
              hydratable
                ? [
                    results.id,
                    child.exprs[0],
                    t.identifier("undefined"),
                    t.callExpression(
                      t.memberExpression(
                        t.memberExpression(
                          t.memberExpression(t.identifier("Array"), t.identifier("prototype")),
                          t.identifier("slice")
                        ),
                        t.identifier("call")
                      ),
                      [
                        t.memberExpression(results.id, t.identifier("childNodes")),
                        t.numericLiteral(0)
                      ]
                    )
                  ]
                : [results.id, child.exprs[0]]
            )
          )
        );
      }
    } else nextPlaceholder = null;
  });
}

function createPlaceholder(path, results, tempPath, i, char) {
  const exprId = path.scope.generateUidIdentifier("el$");
  let contentId;
  results.template += `<!--${char}-->`;
  if (config.hydratable && char === "/") {
    registerImportMethod(path, "getNextMarker");
    contentId = path.scope.generateUidIdentifier("co$");
    results.decl.push(
      t.variableDeclarator(
        t.arrayPattern([exprId, contentId]),
        t.callExpression(t.identifier("_$getNextMarker"), [
          t.memberExpression(t.identifier(tempPath), t.identifier("nextSibling"))
        ])
      )
    );
  } else
    results.decl.push(
      t.variableDeclarator(
        exprId,
        t.memberExpression(
          t.identifier(tempPath),
          t.identifier(i === 0 ? "firstChild" : "nextSibling")
        )
      )
    );
  return [exprId, contentId];
}

function nextChild(children, index) {
  return children[index + 1] && (children[index + 1].id || nextChild(children, index + 1));
}

// reduce unnecessary refs
function detectExpressions(children, index) {
  if (children[index - 1]) {
    const node = children[index - 1].node;
    if (
      t.isJSXExpressionContainer(node) &&
      !t.isJSXEmptyExpression(node.expression) &&
      !isStaticExpressionContainer(children[index - 1])
    )
      return true;
    let tagName;
    if (t.isJSXElement(node) && (tagName = getTagName(node)) && isComponent(tagName)) return true;
  }
  for (let i = index; i < children.length; i++) {
    const child = children[i].node;
    if (t.isJSXExpressionContainer(child)) {
      if (!t.isJSXEmptyExpression(child.expression) && !isStaticExpressionContainer(children[i]))
        return true;
    } else if (t.isJSXElement(child)) {
      const tagName = getTagName(child);
      if (isComponent(tagName)) return true;
      if (config.contextToCustomElements && (tagName === "slot" || tagName.indexOf("-") > -1))
        return true;
      if (
        child.openingElement.attributes.some(
          attr =>
            t.isJSXSpreadAttribute(attr) ||
            (t.isJSXExpressionContainer(attr.value) &&
              (config.generate !== "dom-ssr" ||
                (typeof attr.name.name !== "string" || !attr.name.name.startsWith("on"))) &&
              !(
                t.isStringLiteral(attr.value.expression) ||
                t.isNumericLiteral(attr.value.expression)
              ))
        )
      )
        return true;
      const nextChildren = filterChildren(children[i].get("children"), true);
      if (nextChildren.length) if (detectExpressions(nextChildren, 0)) return true;
    }
  }
}

function contextToCustomElement(path, results) {
  registerImportMethod(path, "currentContext");
  results.exprs.push(
    t.expressionStatement(
      t.assignmentExpression(
        "=",
        t.memberExpression(results.id, t.identifier("_context")),
        t.callExpression(t.identifier("_$currentContext"), [])
      )
    )
  );
}

function createTemplate(path, result, wrap) {
  if (result.id) {
    registerTemplate(path, result);
    if (
      !(result.exprs.length || result.dynamics.length || result.postExprs.length) &&
      result.decl.declarations.length === 1
    ) {
      return result.decl.declarations[0].init;
    } else {
      return t.callExpression(
        t.arrowFunctionExpression(
          [],
          t.blockStatement([
            result.decl,
            ...result.exprs.concat(
              wrapDynamics(path, result.dynamics) || [],
              result.postExprs || []
            ),
            t.returnStatement(result.id)
          ])
        ),
        []
      );
    }
  }
  if (wrap && result.dynamic) {
    registerImportMethod(path, "memo");
    return t.callExpression(t.identifier("_$memo"), [result.exprs[0]]);
  }
  return result.exprs[0];
}

function appendTemplates(path, templates) {
  const declarators = templates.map(template => {
    const tmpl = {
      cooked: template.template,
      raw: template.template
    };
    registerImportMethod(path, "template");
    return t.variableDeclarator(
      template.id,
      t.callExpression(
        t.identifier("_$template"),
        [
          t.templateLiteral([t.templateElement(tmpl, true)], []),
          t.numericLiteral(template.elementCount)
        ].concat(template.isSVG ? t.booleanLiteral(template.isSVG) : [])
      )
    );
  });
  path.node.body.unshift(t.variableDeclaration("const", declarators));
}

function registerTemplate(path, results) {
  const { generate, hydratable } = config;
  const generateIsHydrateOrSsr = hydratable || generate === "dom-ssr";
  let decl;
  if (results.template.length) {
    const templates =
      path.scope.getProgramParent().data.templates ||
      (path.scope.getProgramParent().data.templates = []);
    let templateDef, templateId;
    if ((templateDef = templates.find(t => t.template === results.template))) {
      templateId = templateDef.id;
    } else {
      templateId = path.scope.generateUidIdentifier("tmpl$");
      templates.push({
        id: templateId,
        template: results.template,
        elementCount: results.template.split("<").length - 1,
        isSVG: results.isSVG
      });
    }
    generateIsHydrateOrSsr && registerImportMethod(path, "getNextElement");
    decl = t.variableDeclarator(
      results.id,
      generateIsHydrateOrSsr
        ? t.callExpression(
            t.identifier("_$getNextElement"),
            generate === "dom-ssr" ? [templateId, t.booleanLiteral(true)] : [templateId]
          )
        : t.callExpression(t.memberExpression(templateId, t.identifier("cloneNode")), [
            t.booleanLiteral(true)
          ])
    );
  }
  results.decl.unshift(decl);
  results.decl = t.variableDeclaration("const", results.decl);
}

function wrapDynamics(path, dynamics) {
  if (!dynamics.length) return;
  registerImportMethod(path, "effect");
  if (dynamics.length === 1) {
    const prevValue =
      dynamics[0].key === "classList" || dynamics[0].key === "style"
        ? t.identifier("_$p")
        : undefined;
    return t.expressionStatement(
      t.callExpression(t.identifier("_$effect"), [
        t.arrowFunctionExpression(
          prevValue ? [prevValue] : [],
          setAttr(
            path,
            dynamics[0].elem,
            dynamics[0].key,
            dynamics[0].value,
            dynamics[0].isSVG,
            true,
            prevValue
          )
        )
      ])
    );
  }
  const decls = [],
    statements = [],
    identifiers = [],
    prevId = t.identifier("_p$");
  dynamics.forEach(({ elem, key, value, isSVG }) => {
    const identifier = path.scope.generateUidIdentifier("v$");
    identifiers.push(identifier);
    decls.push(t.variableDeclarator(identifier, value));
    if (key === "classList" || key === "style") {
      const prev = t.memberExpression(prevId, identifier);
      statements.push(
        t.expressionStatement(
          t.assignmentExpression(
            "=",
            prev,
            setAttr(path, elem, key, identifier, isSVG, true, prev)
          )
        )
      );
    } else {
      statements.push(
        t.expressionStatement(
          t.logicalExpression(
            "&&",
            t.binaryExpression("!==", identifier, t.memberExpression(prevId, identifier)),
            setAttr(
              path,
              elem,
              key,
              t.assignmentExpression("=", t.memberExpression(prevId, identifier), identifier),
              isSVG,
              true
            )
          )
        )
      );
    }
  });

  return t.expressionStatement(
    t.callExpression(t.identifier("_$effect"), [
      t.arrowFunctionExpression(
        [prevId],
        t.blockStatement([
          t.variableDeclaration("const", decls),
          ...statements,
          t.returnStatement(prevId)
        ])
      ),
      t.objectExpression(identifiers.map(id => t.objectProperty(id, t.identifier("undefined"))))
    ])
  );
}

function appendToTemplate(template, value) {
  let array;
  if (Array.isArray(value)) {
    [value, ...array] = value;
  }
  template[template.length - 1] += value;
  if (array && array.length) template.push.apply(template, array);
}

function transformElement$1(path, info) {
  let tagName = getTagName(path.node),
    voidTag = VoidElements.indexOf(tagName) > -1,
    results = {
      template: [`<${tagName}`],
      templateValues: [],
      decl: [],
      exprs: [],
      dynamics: []
    };
  if (info.topLevel && config.hydratable) {
    registerImportMethod(path, "getHydrationKey");
    appendToTemplate(results.template, ` _hk="`);
    results.template.push(`"`);
    results.templateValues.push(t.callExpression(t.identifier("_$getHydrationKey"), []));
  }
  transformAttributes$1(path, results);
  appendToTemplate(results.template, ">");
  if (!voidTag) {
    transformChildren$1(path, results);
    appendToTemplate(results.template, `</${tagName}>`);
  }
  return results;
}

function toAttribute(key, isSVG) {
  if (isSVG) {
    const attr = SVGAttributes[key];

    if (attr) {
      if (attr.alias) key = attr.alias;
    } else key = key.replace(/([A-Z])/g, g => `-${g[0].toLowerCase()}`);
  } else {
    const attr = SVGAttributes[key];
    if (attr && attr.alias) key = attr.alias;
    key = key.toLowerCase();
  }
  return key;
}

function setAttr$1(results, name, value, isSVG) {
  name = toAttribute(name, isSVG);
  appendToTemplate(results.template, ` ${name}="`);
  results.template.push(`"`);
  results.templateValues.push(value);
}

function transformAttributes$1(path, results) {
  let children;
  const tagName = getTagName(path.node),
    isSVG = SVGElements.has(tagName),
    hasChildren = path.node.children.length > 0,
    attributes = path.get("openingElement").get("attributes"),
    classAttributes = attributes.filter(
      a => a.node.name && (a.node.name.name === "class" || a.node.name.name === "className")
    );
  // combine class propertoes
  if (classAttributes.length > 1) {
    const first = classAttributes[0].node,
      values = [],
      quasis = [t.TemplateElement({ raw: "" })];
    for (let i = 0; i < classAttributes.length; i++) {
      const attr = classAttributes[i].node,
        isLast = i === classAttributes.length - 1;
      if (!t.isJSXExpressionContainer(attr.value)) {
        quasis.pop();
        quasis.push(
          t.TemplateElement({ raw: (i ? " " : "") + `${attr.value.value}` + (isLast ? "" : " ") })
        );
      } else {
        values.push(attr.value.expression);
        quasis.push(t.TemplateElement({ raw: isLast ? "" : " " }));
      }
      i && attributes.splice(classAttributes[i].key);
    }
    first.value = t.JSXExpressionContainer(t.TemplateLiteral(quasis, values));
  }

  attributes.forEach(attribute => {
    const node = attribute.node;
    if (t.isJSXSpreadAttribute(node)) {
      registerImportMethod(attribute, "ssrSpread");
      appendToTemplate(results.template, " ");
      results.template.push("");
      results.templateValues.push(
        t.callExpression(t.identifier("_$ssrSpread"), [
          isDynamic(attribute.get("argument"), {
            checkMember: true
          })
            ? t.arrowFunctionExpression([], node.argument)
            : node.argument,
          t.booleanLiteral(isSVG),
          t.booleanLiteral(hasChildren)
        ])
      );
      return;
    }

    let value = node.value,
      key = node.name.name;
    if (
      t.isJSXExpressionContainer(value) &&
      (key.toLowerCase() !== key ||
        !(t.isStringLiteral(value.expression) || t.isNumericLiteral(value.expression)))
    ) {
      if (key === "ref" || key.startsWith("on")) return;
      else if (
        key === "children" ||
        key === "textContent" ||
        key === "innerText" ||
        key === "innerHTML"
      ) {
        children = value;
        if (key === "innerHTML") path.doNotEscape = true;
      } else {
        let dynamic = false,
          doEscape = true;
        if (
          isDynamic(attribute.get("value").get("expression"), {
            checkMember: true
          })
        )
          dynamic = true;

        if (key === "style") {
          if (
            t.isJSXExpressionContainer(value) &&
            t.isObjectExpression(value.expression) &&
            !value.expression.properties.some(p => t.isSpreadElement(p))
          ) {
            registerImportMethod(path, "escape");
            const props = value.expression.properties.map((p, i) =>
              t.binaryExpression(
                "+",
                t.stringLiteral(
                  (i ? ";" : "") + (t.isIdentifier(p.key) ? p.key.name : p.key.value) + ":"
                ),
                t.isStringLiteral(p.value)
                  ? t.stringLiteral(escapeHTML(p.value.value))
                  : t.isNumericLiteral(p.value)
                  ? p.value
                  : t.isTemplateLiteral(p.value) && p.value.expressions.length === 0
                  ? t.stringLiteral(escapeHTML(p.value.quasis[0].value.raw))
                  : t.callExpression(t.identifier("_$escape"), [p.value, t.booleanLiteral(true)])
              )
            );
            let res = props[0];
            for (let i = 1; i < props.length; i++) {
              res = t.binaryExpression("+", res, props[i]);
            }
            value.expression = res;
          } else {
            registerImportMethod(path, "ssrStyle");
            value.expression = t.callExpression(t.identifier("_$ssrStyle"), [value.expression]);
          }
          doEscape = false;
        }
        if (key === "classList") {
          registerImportMethod(path, "ssrClassList");
          value.expression = t.callExpression(t.identifier("_$ssrClassList"), [value.expression]);
          key = "class";
          doEscape = false;
        }
        doEscape && registerImportMethod(path, "escape");
        if (dynamic)
          value.expression = t.arrowFunctionExpression(
            [],
            doEscape
              ? t.callExpression(t.identifier("_$escape"), [
                  value.expression,
                  t.booleanLiteral(true)
                ])
              : value.expression
          );
        else if (doEscape)
          value.expression = t.callExpression(t.identifier("_$escape"), [
            value.expression,
            t.booleanLiteral(true)
          ]);
        setAttr$1(results, key, value.expression, isSVG);
      }
    } else {
      if (t.isJSXExpressionContainer(value)) value = value.expression;
      key = toAttribute(key, isSVG);
      appendToTemplate(results.template, ` ${key}`);
      appendToTemplate(results.template, value ? `="${escapeHTML(value.value, true)}"` : `=""`);
    }
  });
  if (!hasChildren && children) {
    path.node.children.push(children);
  }
}

function transformChildren$1(path, results) {
  const { hydratable } = config;
  const filteredChildren = filterChildren(path.get("children"), true);
  filteredChildren.forEach(node => {
    const doNotEscape = path.doNotEscape,
      child = transformNode(node);
    appendToTemplate(results.template, child.template);
    results.templateValues.push.apply(results.templateValues, child.templateValues || []);
    if (child.exprs.length) {
      const multi = checkLength(filteredChildren),
        markers = hydratable && multi;

      if (!doNotEscape) {
        registerImportMethod(path, "escape");
        if (child.dynamic) {
          if (!t.isCallExpression(child.exprs[0]))
            child.exprs[0].body = t.callExpression(t.identifier("_$escape"), [child.exprs[0].body]);
        } else if (!t.isCallExpression(child.exprs[0]))
          child.exprs[0] = t.callExpression(t.identifier("_$escape"), [child.exprs[0]]);
      }

      // boxed by textNodes
      if (markers) {
        appendToTemplate(results.template, `<!--#-->`);
        results.template.push("");
        results.templateValues.push(child.exprs[0]);
        appendToTemplate(results.template, `<!--/-->`);
      } else {
        results.template.push("");
        results.templateValues.push(child.exprs[0]);
      }
    }
  });
}

function createTemplate$1(path, result) {
  if (!result.template) {
    return result.exprs[0];
  }
  registerImportMethod(path, "ssr");
  if (!Array.isArray(result.template))
    return t.callExpression(t.identifier("_$ssr"), [t.stringLiteral(result.template)]);
  if (result.template.length === 1)
    return t.callExpression(t.identifier("_$ssr"), [t.stringLiteral(result.template[0])]);
  const strings = result.template.map(tmpl => t.stringLiteral(tmpl));
  return t.callExpression(t.identifier("_$ssr"), [
    t.arrayExpression(strings),
    ...result.templateValues
  ]);
}

function transformComponent(path) {
  let props = [],
    runningObject = [],
    exprs,
    tagName = getTagName(path.node),
    dynamicSpreads = [],
    dynamicKeys = [];

  if (config.builtIns.indexOf(tagName) > -1) {
    registerImportMethod(path, tagName);
    tagName = `_$${tagName}`;
  }

  path
    .get("openingElement")
    .get("attributes")
    .forEach(attribute => {
      const node = attribute.node;
      if (t.isJSXSpreadAttribute(node)) {
        if (runningObject.length) {
          props.push(t.objectExpression(runningObject));
          runningObject = [];
        }
        const key = t.identifier("k$"),
          memo = t.identifier("m$");
        dynamicSpreads.push(
          t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("keys")), [
            node.argument
          ])
        );
        props.push(
          t.callExpression(
            t.memberExpression(
              t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("keys")), [
                node.argument
              ]),
              t.identifier("reduce")
            ),
            [
              t.arrowFunctionExpression(
                [memo, key],
                t.sequenceExpression([
                  t.assignmentExpression(
                    "=",
                    t.memberExpression(memo, key, true),
                    t.arrowFunctionExpression([], t.memberExpression(node.argument, key, true))
                  ),
                  memo
                ])
              ),
              t.objectExpression([])
            ]
          )
        );
      } else {
        const value = node.value || t.booleanLiteral(true),
          key = t.isJSXNamespacedName(node.name)
            ? `${node.name.namespace.name}:${node.name.name.name}`
            : node.name.name,
          wrapName = t.isValidIdentifier(key) ? t.identifier : t.stringLiteral;
        if (t.isJSXExpressionContainer(value))
          if (key === "ref") {
            if (config.generate === "ssr") return;
            if (t.isLVal(value.expression)) {
              runningObject.push(
                t.objectProperty(
                  t.identifier("ref"),
                  t.arrowFunctionExpression(
                    [t.identifier("r$")],
                    t.conditionalExpression(
                      t.binaryExpression(
                        "===",
                        t.unaryExpression("typeof", value.expression),
                        t.stringLiteral("function")
                      ),
                      t.callExpression(value.expression, [t.identifier("r$")]),
                      t.assignmentExpression("=", value.expression, t.identifier("r$"))
                    )
                  )
                )
              );
            } else if (t.isFunction(value.expression)) {
              runningObject.push(t.objectProperty(t.identifier("ref"), value.expression));
            }
          } else if (
            isDynamic(attribute.get("value").get("expression"), {
              checkMember: true,
              checkTags: true
            })
          ) {
            dynamicKeys.push(t.stringLiteral(key));
            const expr =
              config.wrapConditionals &&
              (t.isLogicalExpression(value.expression) ||
                t.isConditionalExpression(value.expression))
                ? transformCondition(attribute.get("value").get("expression"))
                : t.arrowFunctionExpression([], value.expression);
            runningObject.push(t.objectProperty(wrapName(key), expr));
          } else runningObject.push(t.objectProperty(wrapName(key), value.expression));
        else runningObject.push(t.objectProperty(wrapName(key), value));
      }
    });

  const childResult = transformComponentChildren(path.get("children"));
  if (childResult && childResult[0]) {
    childResult[1] && dynamicKeys.push(t.stringLiteral("children"));
    runningObject.push(t.objectProperty(t.identifier("children"), childResult[0]));
  }
  props.push(t.objectExpression(runningObject));

  if (props.length > 1) {
    props = [
      t.callExpression(t.memberExpression(t.identifier("Object"), t.identifier("assign")), props)
    ];
  }
  dynamicKeys.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase()));
  let dynamics;
  if (dynamicSpreads.length) {
    if (dynamicSpreads.length === 1 && !dynamicKeys.length) dynamics = dynamicSpreads[0];
    else {
      dynamicKeys.push.apply(
        dynamicKeys,
        dynamicSpreads.map(s => t.spreadElement(s))
      );
      dynamics = t.arrayExpression(dynamicKeys);
    }
  } else if (dynamicKeys.length) {
    const hash = dynamicKeys.map(k => k.value).join("|"),
      childKeys =
        path.scope.getProgramParent().data.childKeys ||
        (path.scope.getProgramParent().data.childKeys = new Map());
    if (!childKeys.has(hash)) {
      const identifier = path.scope.generateUidIdentifier("ck$");
      childKeys.set(hash, { identifier, dynamicKeys });
      dynamics = identifier;
    } else {
      dynamics = childKeys.get(hash).identifier;
    }
  }

  registerImportMethod(path, "createComponent");
  const componentArgs = [tagNameToIdentifier(tagName), props[0]];
  if (dynamics) componentArgs.push(dynamics);
  exprs = [t.callExpression(t.identifier("_$createComponent"), componentArgs)];

  return { exprs, template: "", component: true };
}

function transformComponentChildren(children) {
  const createTemplate$2 = config.generate === "ssr" ? createTemplate$1 : createTemplate,
    filteredChildren = filterChildren(children);
  if (!filteredChildren.length) return;
  let dynamic = false;

  let transformedChildren = filteredChildren.map(path => {
    if (t.isJSXText(path.node)) {
      return t.stringLiteral(trimWhitespace(path.node.extra.raw));
    } else {
      const child = transformNode(path, {
        topLevel: true,
        componentChild: true
      });
      dynamic = dynamic || child.dynamic;
      return createTemplate$2(path, child, filteredChildren.length > 1);
    }
  });

  if (filteredChildren.length === 1) {
    transformedChildren = transformedChildren[0];
    if (
      !t.isJSXExpressionContainer(filteredChildren[0]) &&
      !t.isJSXSpreadChild(filteredChildren[0]) &&
      !t.isJSXText(filteredChildren[0])
    ) {
      transformedChildren =
        t.isCallExpression(transformedChildren) && !transformedChildren.arguments.length
          ? transformedChildren.callee
          : t.arrowFunctionExpression([], transformedChildren);
      dynamic = true;
    }
  } else {
    transformedChildren = t.arrowFunctionExpression([], t.arrayExpression(transformedChildren));
    dynamic = true;
  }
  return [transformedChildren, dynamic];
}

function transformFragmentChildren(children, results) {
  const createTemplate$2 = config.generate === "ssr" ? createTemplate$1 : createTemplate,
    filteredChildren = filterChildren(children),
    singleChild = filteredChildren.length === 1,
    childNodes = filteredChildren.map(path => {
      if (t.isJSXText(path.node)) return t.stringLiteral(trimWhitespace(path.node.extra.raw));
      const child = transformNode(path, { topLevel: true });
      return createTemplate$2(path, child, !singleChild);
    });
  results.exprs.push(singleChild ? childNodes[0] : t.arrayExpression(childNodes));
}

function transformJSX(path, { opts }) {
  Object.assign(config, opts);
  const result = transformNode(
    path,
    t.isJSXFragment(path.node)
      ? {}
      : {
          topLevel: true
        }
  );
  const template = config.generate === "ssr" ? createTemplate$1 : createTemplate;
  path.replaceWith(template(path, result, false));
}

function transformNode(path, info = {}) {
  const node = path.node;
  if (t.isJSXElement(node)) {
    let tagName = getTagName(node);
    if (isComponent(tagName)) return transformComponent(path);
    const element = config.generate === "ssr" ? transformElement$1 : transformElement;
    return element(path, info);
  } else if (t.isJSXFragment(node)) {
    let results = { template: "", decl: [], exprs: [], dynamics: [] };
    transformFragmentChildren(path.get("children"), results);
    return results;
  } else if (t.isJSXText(node) || isStaticExpressionContainer(path)) {
    const text = trimWhitespace(
      t.isJSXExpressionContainer(node)
        ? t.isTemplateLiteral(node.expression)
          ? node.expression.quasis[0].value.raw
          : node.expression.value.toString()
        : node.extra.raw
    );
    if (!text.length) return null;
    const results = {
      template: text,
      decl: [],
      exprs: [],
      dynamics: [],
      postExprs: [],
      text: true
    };
    if (!info.skipId && config.generate !== "ssr")
      results.id = path.scope.generateUidIdentifier("el$");
    return results;
  } else if (t.isJSXExpressionContainer(node)) {
    if (t.isJSXEmptyExpression(node.expression)) return null;
    if (
      !isDynamic(path.get("expression"), {
        checkMember: true,
        checkTags: !!info.componentChild
      })
    ) {
      return { exprs: [node.expression], template: "" };
    }
    const expr =
      config.wrapConditionals &&
      (t.isLogicalExpression(node.expression) || t.isConditionalExpression(node.expression))
        ? transformCondition(path.get("expression"))
        : t.arrowFunctionExpression([], node.expression);
    return {
      exprs: [expr],
      template: "",
      dynamic: true
    };
  } else if (t.isJSXSpreadChild(node)) {
    if (
      !isDynamic(path.get("expression"), {
        checkMember: true
      })
    )
      return { exprs: [node.expression], template: "" };
    const expr = t.arrowFunctionExpression([], node.expression);
    return {
      exprs: [expr],
      template: "",
      dynamic: true
    };
  }
}

// add to the top/bottom of the module.
var postprocess = path => {
  if (path.scope.data.events) {
    registerImportMethod(path, "delegateEvents");
    path.node.body.push(
      t.expressionStatement(
        t.callExpression(t.identifier("_$delegateEvents"), [
          t.arrayExpression(Array.from(path.scope.data.events).map(e => t.stringLiteral(e)))
        ])
      )
    );
  }
  if (path.scope.data.childKeys) {
    const declarators = [...path.scope.data.childKeys.values()].map(o =>
      t.variableDeclarator(o.identifier, t.arrayExpression(o.dynamicKeys))
    );
    path.node.body.unshift(t.variableDeclaration("const", declarators));
  }
  if (path.scope.data.templates) appendTemplates(path, path.scope.data.templates);
};

var index = () => {
  return {
    name: "JSX DOM Expressions",
    inherits: SyntaxJSX,
    visitor: {
      JSXElement: transformJSX,
      JSXFragment: transformJSX,
      Program: {
        exit: postprocess
      }
    }
  };
};

module.exports = index;
